#  **Детальное ТЗ: Наследование, Обобщения, Ссылочные типы, Клонирование**

---

# **1. Задание: Наследование — иерархия Vehicle / Car / ElectricCar**

## **Цель**

Научиться применять наследование, переопределять методы, использовать `super`.

## **Требования**

1. Создать базовый класс **Vehicle** с полями:

   * `String brand`
   * `int year`
2. Определить методы:

   * `void move()` — выводит сообщение `"Vehicle is moving"`
   * Геттеры/сеттеры.
3. Создать класс **Car**, который **extends Vehicle**.

   * Добавить поле `int maxSpeed`.
   * Переопределить метод `move()`: вывести `"Car is driving"`.
   * Добавить конструктор, который вызывает `super(...)`.
4. Создать класс **ElectricCar**, который **extends Car**.

   * Добавить поле `int batteryLevel`.
   * Переопределить метод `move()`:
     `"Electric car is driving silently"`
5. Создать `Main` класс и протестировать:

   * Создать объект каждого класса.
   * Вызвать `move()`.
   * Продемонстрировать порядок вызова конструкторов.

## **Критерии выполнения**

* Классы оформлены в отдельные файлы.
* Использованы ключевые слова: `extends`, `super`, `@Override`.
* Переопределение работает корректно.
* Иерархия соблюдена: `Vehicle → Car → ElectricCar`.

---

# **2. Задание: Обобщения — класс Pair<K, V>**

## **Цель**

Научиться создавать собственный generic-класс, разбираться в типах и параметризации.

## **Требования**

1. Создать generic-класс:

```java
public class Pair<K, V> {
    private K key;
    private V value;
}
```

2. Реализовать:

   * Конструктор
   * Геттеры/сеттеры
   * Метод `toString()`

3. В Main протестировать:

   * Пару `<String, Integer>`
   * Пару `<Integer, List<String>>`
   * Пару `<String, String>`

4. Добавить метод:

```java
public void printTypes() {
    System.out.println("Key type: " + key.getClass().getSimpleName());
    System.out.println("Value type: " + value.getClass().getSimpleName());
}
```

## **Критерии выполнения**

* Применён generics.
* Класс универсальный (поддерживает любые типы).
* Код компилируется без `unchecked` предупреждений.
* Типы корректно выводятся.

---

# **3. Задание: Ссылочные типы — изменение объекта внутри метода**

## **Цель**

Понять, что в Java передаются **ссылки по значению**, и объект можно изменить внутри метода.

## **Требования**

1. Создать класс:

```java
class User {
    String name;
}
```

2. Создать метод:

```java
void changeUser(User u) {
    u.name = "Changed inside method";
}
```

3. В Main:

   * Создать объект User: `User u = new User("Initial")`
   * Передать его в метод.
   * Вывести значения до и после вызова.

4. Добавить метод, который **заменяет ссылку**:

```java
void reassignUser(User u) {
    u = new User("New object");
}
```

5. Показать, что после вызова внешний объект не меняется.

## **Критерии выполнения**

* Демонстрируется отличие изменения полей объекта и переназначения ссылки.
* Вывод в консоль объясняет поведение.

---

# **4. Задание: Клонирование объектов — shallow & deep copy**

## **Цель**

Научиться различать поверхностное и глубокое копирование.

## **Требования**

### **4.1. Создать классы:**

```java
class Profile {
    String bio;
}

class User implements Cloneable {
    String name;
    Profile profile;
}
```

---

## **4.2. Реализовать поверхностное копирование**

### **Требования**

1. Переопределить `clone()`:

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    return super.clone(); // shallow
}
```

2. В Main:

   * Создать `User u1` с Profile.
   * Создать копию `User u2 = (User) u1.clone();`
   * Изменить `u1.profile.bio`
   * Проверить, что изменения отражаются в `u2`.

---

## **4.3. Реализовать глубокое копирование**

### **Требования**

1. Изменить метод clone():

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    User copied = (User) super.clone();
    copied.profile = new Profile();
    copied.profile.bio = this.profile.bio;
    return copied;
}
```

2. Проверить:

   * Изменение bio у оригинала не влияет на копию.

---

## **Критерии выполнения**

* `Cloneable` реализован.
* Поверхностное и глубокое копирование работают корректно.
* Разница видна в выводе.
* Показан корректный цикл клонирования вложенных объектов.
