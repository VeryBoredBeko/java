# Задачи

## **1. Инверсия иерархии**

Даны классы: Device → SmartDevice → SmartWatch.
Предложите, как можно переработать иерархию так, чтобы преобразования типов стали минимально необходимыми. Какие проблемы текущей иерархии приводят к частым кастам?

---

## **2. «Лишнее» наследование**

В проекте созданы классы: Vehicle → Car → SportCar → DriftCar → ExtremeDriftCar.
Задача: объяснить, почему чрезмерная глубина наследования приводит к множественным приведением типов и ошибкам. Как бы вы упростили архитектуру?

---

## **3. Неверный базовый класс**

Есть классы Bird и Plane, оба «умеют летать», но Plane унаследован от Bird.
Определите:
— в каких ситуациях преобразование Bird → Plane будет логически недопустимым,
— и предложите правильную архитектуру без необходимости приведения.

---

## **4. Проблема «забытых методов»**

Иерархия: Media → Audio → MusicTrack.
Студент столкнулся с ситуацией, когда объект MusicTrack был приведён к Audio, и некоторые методы перестали быть видны. Объясните, почему это нормально и как правильно проектировать API, чтобы избежать путаницы.

---

## **5. Ложное обобщение**

Класс Animal → Human → Child.
Придумайте задачу, где приведение Human → Animal корректно, но обедняет поведение, и студент теряет часть важной логики, ошибочно думая, что «всё работает одинаково». Как это исправить?

---

## **6. Наследование VS композиция**

Иерархия: File → ImageFile → JpegFile.
Опишите ситуацию, где студент попытался решить задачу через наследование и превращение типов, но правильнее было бы использовать композицию (например, класс Decoder внутри File). Почему композиция уменьшает необходимость кастов?

---

## **7. Ошибка «срезания» (object slicing)**

Хотя в Java/C# object slicing нет, опишите гипотетическую задачу, где студент мысленно ожидает поведения «срезания» (как в C++), а в JVM-х языках всё работает наоборот — через ссылки. Как это влияет на ожидания при приведении типов?

---

## **8. Множественная логика в базовом классе**

Есть классы Worker → Developer и Worker → Designer.
Базовый класс содержит поле `tools`, но Developer использует IDE, а Designer — графический планшет.
Придумайте задачу, где попытка привести Worker → Developer приводит к логической ошибке, и опишите, как правильное проектирование решает проблему.

---

## **9. Проблема «наследования ради одного метода»**

Класс Document → PdfDocument → SignedPdfDocument.
Студент унаследовал SignedPdfDocument только ради метода sign().
Предложите задачу, где это приводит к невозможности корректного приведения типов в обработчике документа, и объясните, почему интерфейс был бы лучше.

---

## **10. Опасные предположения**

В коллекции List<Shape> лежат Circle, Square и TextShape (надпись).
Студент предполагает, что если объект имеет метод draw(), значит он точно Shape.
Придумайте задачу, где такое предположение приводит к неправильному касту. Как выявить такие ошибки заранее?

---
